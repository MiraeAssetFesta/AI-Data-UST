```python
import FinanceDataReader as fdr
import numpy as np
import pandas as pd
from scipy.optimize import minimize
from scipy.stats import norm
import matplotlib.pyplot as plt

# 종목 티커 리스트
tickers = ["NEE", "AEP", "SO", "D", "DUK", "PCG", "CEG", "PEG", "SRE", "EXC"]

# 데이터 불러오기
def fetch_data(tickers, start_date, end_date):
    data = pd.DataFrame()
    for ticker in tickers:
        try:
            df = fdr.DataReader(ticker, start_date, end_date)
            if 'Close' in df.columns:
                df = df[['Close']]
                df.columns = [ticker]
                data = pd.concat([data, df], axis=1)
        except Exception as e:
            print(f"Failed to fetch data for {ticker}: {e}")
    return data

# 월간 수익률 계산
def calculate_monthly_returns(data):
    return data.resample('M').ffill().pct_change().dropna()

# 데이터 로드 및 시장 벤치마크 데이터 로드
start_date = '2019-06-30'
end_date = '2024-06-30'
all_data = fetch_data(tickers + ['US500'], start_date, end_date)  # S&P 500을 시장 수익률로 포함
all_data = all_data.dropna(axis=1, how='all')  # 모든 값이 NaN인 열 제거
monthly_returns = calculate_monthly_returns(all_data)

# 필요한 계산 함수들 정의
def calculate_std_dev(returns):
    return returns.std()

def calculate_max_drawdown(returns):
    cumulative_returns = (1 + returns).cumprod()
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns - peak) / peak
    return drawdown.min()

def calculate_sharpe_ratio(returns, risk_free_rate):
    excess_returns = returns - risk_free_rate
    return excess_returns.mean() / excess_returns.std() * np.sqrt(12)  # 연간 샤프 비율

def calculate_beta(asset_returns, market_returns):
    covariance = asset_returns.cov(market_returns)
    market_variance = market_returns.var()
    return covariance / market_variance

def calculate_treynor_ratio(asset_returns, beta, risk_free_rate):
    excess_returns = asset_returns - risk_free_rate
    return excess_returns.mean() / beta

def calculate_information_ratio(asset_returns, market_returns):
    excess_returns = asset_returns - market_returns
    return excess_returns.mean() / excess_returns.std()

def calculate_turnover(previous_weights, current_weights):
    return np.sum(np.abs(current_weights - previous_weights))

def calculate_sparsity(weights):
    non_zero_weights = np.count_nonzero(weights)
    return (len(weights) - non_zero_weights) / len(weights)

def calculate_correlation(asset_returns, market_returns):
    return asset_returns.corr(market_returns)

def calculate_covariance(asset_returns, market_returns):
    return asset_returns.cov(market_returns)

def calculate_diversification_index(weights):
    return 1 / np.sum(weights ** 2)

# SLOPE 페널티 함수
def slope_penalty(weights, lambdas):
    sorted_weights = np.sort(np.abs(weights))[::-1]
    padded_lambdas = np.pad(lambdas, (0, len(sorted_weights) - len(lambdas)), 'constant', constant_values=(0, 0))
    return np.sum(padded_lambdas * sorted_weights)

# 최적화 문제 정의
def portfolio_optimization(returns, target_return, lambdas):
    num_assets = returns.shape[1]
    mean_returns = returns.mean()
    cov_matrix = returns.cov()

    def objective(weights):
        portfolio_return = np.dot(weights, mean_returns)
        portfolio_risk = np.dot(weights.T, np.dot(cov_matrix, weights))
        penalty = slope_penalty(weights, lambdas)
        return portfolio_risk - portfolio_return + penalty

    constraints = (
        {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # 가중치 합은 1
        {'type': 'eq', 'fun': lambda x: np.dot(x, mean_returns) - target_return}  # 목표 수익률
    )
    bounds = tuple((0, 1) for _ in range(num_assets))  # 각 자산의 최대 가중치 제한
    initial_weights = np.array([1.0 / num_assets] * num_assets)

    result = minimize(objective, initial_weights, method='SLSQP', bounds=bounds, constraints=constraints)
    return result.x

# 목표 수익률 설정 
target_return = 0.007

# 람다 값 계산
a_values = np.logspace(-5, 2, num=30)
p = len(tickers)
lambda_results = []

for a in a_values:
    lambdas = [a * norm.ppf(1 - 0.01 * i / (2 * p)) for i in range(1, p + 1)]
    lambda_results.append(lambdas)

# 최적화 수행
optimal_weights_list = []

for lambdas in lambda_results:
    optimal_weights = portfolio_optimization(monthly_returns[tickers], target_return, lambdas)
    optimal_weights_list.append(optimal_weights)

# 결과 시각화
def visualize_lambda_effects(optimal_weights_list, a_values):
    plt.figure(figsize=(14, 7))
    for i, ticker in enumerate(tickers):
        weights = [optimal_weights[i] for optimal_weights in optimal_weights_list]
        plt.plot(range(1, 31), weights, label=ticker)  # X축을 1에서 30까지 설정
    
    plt.xlabel('Grid Lambda')
    plt.ylabel('Weights')
    plt.title('Optimal Weights for Different Lambda Values')
    plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    plt.tight_layout()
    plt.show()

# 시각화
visualize_lambda_effects(optimal_weights_list, a_values)
```
